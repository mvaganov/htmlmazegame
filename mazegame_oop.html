<!DOCTYPE html>
<html>
    <head>
        <style>
            body { margin:0; padding:0; }
            .icon {position:absolute; left:0px; top:0px; }
            .iconToClone { position:absolute; left:0px; top:0px; display:none; }
            .bottomUI { position:fixed; left:0px; bottom:0px; width:100%; height:40px; }
        </style>
    </head>
    <body onload="startGame()">
        <img src="http://codegiraffe.com/htmlgame/player.png" id="player" class="iconToClone">
        <img src="http://codegiraffe.com/htmlgame/key.png" id="key" class="iconToClone">
        <img src="http://codegiraffe.com/htmlgame/door.png" id="door" class="iconToClone">
        <img src="http://codegiraffe.com/htmlgame/goal.png" id="goal" class="iconToClone">
        <div class="bottomUI" id="bottomUI"></div>
        <script>
const MazeTilesString =
"################"+
"#S   k#k #     #"+
"# ######d#k## ##"+
"# #    d ###   #"+
"# # ## #  k# # #"+
"# #dk# # ### # #"+
"#   ## ###   # #"+
"##d# #   #d### #"+
"#  # ###   #   #"+
"# ##   #####d###"+
"#    #    k#  G#"+
"################";

const MazeTileColors = {
    '#': '#000',
    'S': '#ddd',
    'G': '#0F0',
    'd': '#883',
    'k': '#fed',
    undefined: '#fff'
};

const MazeTileIcon = {
    'S' : "player",
    'G' : "goal",
    'd' : "door",
    'k' : "key",
}

const TileCollisionFunctions = {
    '#' : movePlayerBackToPreviousPosition,
    'd' : walkIntoDoor,
    'k' : walkIntoKey,
    'G' : walkIntoGoal
}

const ESCAPE = 27, UP = 38, DOWN = 40, LEFT = 37, RIGHT = 39;
const KeyMapRules = [
    [UP, ()=>{ APP.translatePlayer(0, -1); }],
    [LEFT, ()=>{ APP.translatePlayer(-1, 0); }],
    [DOWN, ()=>{ APP.translatePlayer(0, 1); }],
    [RIGHT, ()=>{ APP.translatePlayer(1, 0); }],
    [ESCAPE, ()=>{ startGame(); }],
    ['\n'.charCodeAt(0), movePlayerToStart],
    ['\r'.charCodeAt(0), movePlayerToStart],
    ['W'.charCodeAt(0), ()=>{ APP.translatePlayer(0, -1); }],
    ['A'.charCodeAt(0), ()=>{ APP.translatePlayer(-1, 0); }],
    ['S'.charCodeAt(0), ()=>{ APP.translatePlayer(0, 1); }],
    ['D'.charCodeAt(0), ()=>{ APP.translatePlayer(1, 0); }],
];

const SquareWidthPixels = 32, SquareHeightPixels = 32;
const MazeWidthTiles = 16, MazeHeightTiles = 12;
const IconOffsetX = 8, IconOffsetY = 8;

var APP;

function startGame() {
	if (!APP) {
		APP = new App();
		document.onkeydown = (e) => APP.handleKeypress(e);
	}
	APP.initialize(KeyMapRules);
}

class Map2d {
	constructor(source, columns, rows) {
		this.mazeDataString = source;
		this.width = columns;
		this.height = rows;
	}

	getAt(col, row) {
		return this.mazeDataString[this.getIndex(col, row)];
	}

	getIndex(col, row) {
		return row * MazeWidthTiles + col;
	}

	setAt(col, row, tileCharacter) {
		this.mazeDataString = Map2d.characterReplace(this.mazeDataString, this.getIndex(col, row), ' ');
	}

	static characterReplace(str, index, replacement) {
		return str.substring(0, index) + replacement + str.substring(index + 1);
	}

}

class Map2dGraphic extends Map2d {
	constructor(source, columns, rows, SquareWidthPixels, SquareHeightPixels, MazeTileColors) {
		super(source, columns, rows);
		this.SquareWidthPixels = SquareWidthPixels;
		this.SquareHeightPixels = SquareHeightPixels;
		this.MazeTileColors = MazeTileColors;
	}

	drawGameTiles(ctx) {
		let col = 0, row = 0;
		for (let row = 0; row < this.height; row++) {
			for (let col = 0; col < this.width; col++) {
				this.drawMapTile(ctx, col, row);
			}
		}
	}

	drawMapTile(ctx, col, row) {
		let mazeTile = this.getAt(col, row);
		let color = this.MazeTileColors[mazeTile];
		if (color == undefined) {
			color = this.MazeTileColors[undefined];
		}
		this.drawTileWithColor(ctx, col, row, color);
	}

	drawTileWithColor(ctx, col, row, color) {
		if (!color) {
			return;
		}
		let pixel = this.pixelLocationOfTile(col, row);
		ctx.fillStyle = color;
		ctx.fillRect(pixel.x, pixel.y, this.SquareWidthPixels, this.SquareHeightPixels);
	}

	pixelLocationOfTile(col, row) {
		return {
			x : col * this.SquareWidthPixels,
			y : row * this.SquareHeightPixels,
		};
	}
}

class TileGameObjects {
	constructor(MazeTileIcon, SquareWidthPixels, SquareHeightPixels, InitialMapFunction) {
		this.MazeTileIcon = MazeTileIcon;
		this.gameObjects = [];
		this.SquareWidthPixels = SquareWidthPixels;
		this.SquareHeightPixels = SquareHeightPixels;
		this.InitialMapFunction = InitialMapFunction;
	}

	pixelLocationOfTile(col, row) {
		return {
			x : col * this.SquareWidthPixels,
			y : row * this.SquareHeightPixels,
		};
	}

	initailize() {
		if (this.gameObjects) {
			this.removeAllObjects();
		}
	}

	drawGameObjects(ctx) {
		for(let i = 0; i < this.gameObjects.length; ++i) {
			this.drawGameObject(ctx, this.gameObjects[i]);
		}
	}

	drawGameObject(ctx, gameObject) {
		let pixelLocation = this.pixelLocationOfTile(gameObject.x, gameObject.y);
		this.moveIconToPixelLocation(gameObject.icon, pixelLocation);
		// if (Dom.isElementVisible(gameObject.icon)) {
		// 	this.drawTileWithColor(ctx, gameObject.x, gameObject.y, gameObject.tileColor);
		// }
	}

	moveIconToPixelLocation(icon, pixelLocation) {
		icon.style.left = pixelLocation.x + "px";
		icon.style.top = pixelLocation.y + "px";
	}

	createTileIconObjects() {
		for (let row = 0; row < MazeHeightTiles; row++) {
			for(let col = 0; col < MazeWidthTiles; col++) {
				this.createTileObject(col, row);
			}
		}
		Dom.hideElements(Object.values(this.MazeTileIcon));
	}

	createTileObject(col, row) {
		let mazeTile = this.InitialMapFunction(col,row);
		let icon = this.MazeTileIcon[mazeTile];
		//let color = MazeTileColors[mazeTile];
		if (icon != undefined) {
			//this.createNewTileIconObjectAtLocation(icon, color, col, row);
			this.createNewTileIconObjectAtLocation(icon, col, row);
		}
	}

	//createNewTileIconObjectAtLocation(originalIconId, tileColor, col, row) {
	createNewTileIconObjectAtLocation(originalIconId, col, row) {
		let originalIconObject = Dom.byID(originalIconId);
		let icon = originalIconObject.cloneNode(true);
		this.setIconSizeToMatchTileSize(icon);
		document.body.appendChild(icon);
		let gameObject = {
			x: col,
			y: row,
			icon: icon,
			name: originalIconId,
			//tileColor: tileColor
		};
		this.gameObjects.push(gameObject);
		icon.id += this.gameObjects.length;
		let pixel = this.pixelLocationOfTile(col, row);
		this.moveIconToPixelLocation(icon, pixel);
		icon.style.display = 'inline';
	}

	findGameObject(name) {
		for (let i = 0; i < this.gameObjects.length; i++) {
			if (this.gameObjects[i].name == name) {
				return this.gameObjects[i];
			}
		}
	}

	getObjectAt(col, row, name) {
		for (let i = 0; i < this.gameObjects.length; i++) {
			let gameObject = this.gameObjects[i];
			if(gameObject && gameObject.y == row && gameObject.x == col && gameObject.name == name) {
				return gameObject;
			}
		}
		return null;
	}

	removeAllObjects() {
		for (let i = 0; i < this.gameObjects.length; i++) {
			let obj = this.gameObjects[i]
			obj.icon.parentNode.removeChild(obj.icon);
		}
		this.gameObjects = [];
	}

	setIconSizeToMatchTileSize(itm) {
		itm.style.width = SquareWidthPixels + "px";
		itm.style.height = SquareHeightPixels + "px";
	}
}

class Dom {
	static isElementVisible(element) {
		return element && element.style.display != 'none' && element.style.visibility != 'hidden';
	}

	static hideElements(idNames) {
		for (let i = 0; i < idNames.length; i++) {
			let object = this.byID(idNames[i]);
			object.style.display = 'none';
		}
	}

	static byID(id) {
		return document.getElementById(id);
	}
}

class App {
	constructor() {
		this.canvas = document.createElement("canvas");
		document.body.insertBefore(this.canvas, document.body.childNodes[0]);
	}
	initialize(keyMapArray) {
		this.keyMap = { };
		this.applyKeyMapRules(keyMapArray);
		this.player = { x : 0, y : 0 };
		this.canvas.width = MazeWidthTiles * SquareWidthPixels;
		this.canvas.height = MazeHeightTiles * SquareHeightPixels;
		this.context = this.canvas.getContext("2d");
		this.keys = 0;
		this.map = new Map2dGraphic(MazeTilesString, MazeWidthTiles, MazeHeightTiles, SquareWidthPixels, SquareHeightPixels, MazeTileColors);
		if (!this.objMap) {
			this.objMap = new TileGameObjects(MazeTileIcon, SquareWidthPixels, SquareHeightPixels,
				(col, row) => {
					return this.map.getAt(col, row);
				}
			);
		}
		this.objMap.initailize();
		this.objMap.createTileIconObjects();
		this.setupPlayer();
		createInventoryUI();
		updateKeyCountUI();
		movePlayerToStart();
		this.drawGame();
	}
	
	handleKeypress(e) {
		this.userKeyInput(e);
		this.updateGame();
		this.drawGame();
	}

	drawGame() {
		let ctx = this.canvas.getContext("2d");
		this.map.drawGameTiles(ctx);
		this.objMap.drawGameObjects(ctx);
		if(this.winner) {
			this.drawWinMessage(ctx, "Winner!", "#0f0");
		}
	}

	clear() {
		this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
	}

	applyKeyMapRules(keyMapArray) {
		for (let i = 0; i < keyMapArray.length; ++i) {
			let key = keyMapArray[i][0];
			let keyFunction = keyMapArray[i][1];
			this.keyMap[key] = keyFunction;
		}
	}

	drawWinMessage(ctx, message, color) {
		ctx.font = "30px Arial";
		ctx.fillStyle = color;
		ctx.textAlign = "center";
		ctx.fillText(message, this.canvas.width/2, this.canvas.height/2);
	}

	userKeyInput(e) {
		e = e || window.event;
		let keyMapFunction = this.keyMap[e.keyCode];
		if (keyMapFunction) {
			keyMapFunction();
		} else {
			console.log("unknown key: "+e.keyCode);
		}
	}

	translatePlayer(deltaX, deltaY) {
		this.oldPosition = {
			x : this.player.x,
			y : this.player.y
		};
		this.player.x += deltaX;
		this.player.y += deltaY;
	}

	updateGame() {
		let playerX = this.player.x;
		let playerY = this.player.y;
		let playerTileFloor = this.map.getAt(playerX, playerY);
		if (playerX < 0 || playerX >= MazeWidthTiles || playerY < 0 || playerY >= MazeHeightTiles) {
			this.movePlayerBackToPreviousPosition();
		}
		let tileCollisionFunction = TileCollisionFunctions[playerTileFloor];
		if (tileCollisionFunction != undefined) {
			tileCollisionFunction();
		}
	}

	setupPlayer() {
		this.player = this.objMap.findGameObject("player");
	}
}

function movePlayerBackToPreviousPosition() {
	APP.player.x = APP.oldPosition.x;
	APP.player.y = APP.oldPosition.y;
}

function walkIntoDoor() {
	if (APP.keys <= 0) {
		movePlayerBackToPreviousPosition();
	} else {
		APP.keys--;
		updateKeyCountUI();
		openDoor(APP.player.x, APP.player.y);
	}
}

function walkIntoKey() {
	APP.keys++;
	updateKeyCountUI();
	APP.map.setAt(APP.player.x, APP.player.y, ' ');
	APP.objMap.getObjectAt(APP.player.x, APP.player.y, "key").icon.style.visibility = 'hidden';
}

function walkIntoGoal() {
	APP.winner = true;
}

function openDoor(col, row) {
	APP.map.setAt(col, row, ' ');
	APP.objMap.getObjectAt(col, row, "door").icon.style.display = 'none';
}

function movePlayerToStart() {
	let index = APP.map.mazeDataString.indexOf('S');
	APP.player.x = index % APP.map.width;
	APP.player.y = parseInt(index / APP.map.width);
}

let keyCountUI = null;

function createInventoryUI() {
	if (keyCountUI != null) {
		return;
	}
	addKeyInventoryUiToDom();
}

function addKeyInventoryUiToDom() {
	let uiArea = Dom.byID("bottomUI");
	let icon = Dom.byID("key").cloneNode(true);
	APP.objMap.setIconSizeToMatchTileSize(icon);
	icon.style.display = 'inline'
	icon.style.position = 'relative';
	uiArea.appendChild(icon);
	keyCountUI = document.createElement("span");
	keyCountUI.style.position = 'relative';
	uiArea.appendChild(keyCountUI);
}

function updateKeyCountUI() {
	keyCountUI.innerHTML = "x" + APP.keys;
}

        </script>
    </body>
</html>
