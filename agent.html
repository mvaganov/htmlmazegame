<!DOCTYPE html>
<html>
	<head>
	<style>
		body { margin:0; padding:0; }
	</style>
	</head>
	<body onload="mainLoop()" onmousemove="mouseMoveInterrupt()" onkeydown="keyDownInterrupt()" onmousedown="mouseDownInterrupt()">
		<script>
var APP;
var agents;
var getPlayer = () => agents[0];

function forEachAgent(whatToDo) {
	for (let i = 0; i < agents.length; i++) {
		whatToDo(agents[i]);
	}
}

function mainLoop() {
	APP.processInput();
	APP.update();
	APP.drawGame();
	setTimeout(mainLoop, 10);
}

function mouseMoveInterrupt(e) {
	APP.updateMousePosition(e || window.event);
}

function keyDownInterrupt(e) {
	APP.updateKeyInput(e || window.event);
}

function mouseDownInterrupt(e) {
	APP.updateMouseDownInput(e || window.event);
}

class App {
	constructor() {
		this.canvas = document.createElement("canvas");
		this.now = Date.now();
		console.log("creating "+this.now);
		this.then = Date.now();
		this.targetFps = 90;
		this.mouse = {x: 0, y: 0};
		this.canvas.width = 800;
		this.canvas.height = 600;
		this.context = this.canvas.getContext("2d");
		document.body.insertBefore(this.canvas, document.body.childNodes[0]);
		document.onkeydown = this.userkey;
	}

	updateKeyInput(e) {
		const ESCAPE = 27;
		if (e.keyCode === ESCAPE) {
			this.clearScreen = true;
		} else {
			console.log("key: "+e.keyCode)
		}
	};

	updateMousePosition(e) {
		if (!e) {
			return;
		}
		this.mouse.x = e.clientX;
		this.mouse.y = e.clientY;
	}

	updateMouseDownInput(e) {
		this.updateMousePosition(e);
		forEachAgent(a => a.setEndOfLine(this.mouse.x, this.mouse.y));
	}

	processInput() {
		if (this.mouse) {
		}
		if (this.clearScreen) {
			this.clear();
			this.clearScreen = false;
		}
	}

	drawGame() {
		this.clear();
		this.ctx = this.canvas.getContext("2d");
		this.ctx.font = "30px Arial";
		this.ctx.fillStyle = "#0f0";
		this.ctx.textAlign = "center";
		this.ctx.fillText("Hello World!", this.canvas.width / 2, this.canvas.height / 2);
		forEachAgent(a => a.draw(this.ctx));
	}

	update() {
		this.updateTiming();
		let timeHasPassed = this.deltaTime > 0;
		if (timeHasPassed) { 
			let deltatime = this.deltaTime / 1000;
			forEachAgent(a => a.update(deltatime));
		}
	}

	updateTiming() {
		this.now = Date.now();
		let deltaTime = this.now - this.then;
		if (deltaTime) { 
			this.deltaTime = deltaTime;
		}
		this.then = this.now;
	}

	clear() {
		this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
	}
};

class V2 {
	constructor(x = 0, y = 0) {
		this.x = x; this.y = y;
		this.assert();
	}
	assert() { if (this.x == undefined || this.y == undefined) { throw new Error("undefined values! " + this.toString()); } }
	add(v) { this.x += v.x; this.y += v.y; this.assert(); return this; }
	sub(v) { this.x -= v.x; this.y -= v.y; this.assert(); return this; }
	mul(v) {
		       if (typeof v === "object") {
			this.x *= v.x; this.y *= v.y;
		} else if (typeof v === "number") {
			this.x *= v; this.y *= v;
		}
		this.assert();
		return this;
	}
	div(v) {
		       if (typeof v === "object") {
			this.x /= v.x; this.y /= v.y;
		} else if (typeof v === "number") {
			this.x /= v; this.y /= v;
		}
		this.assert();
		return this;
	}
	magnitudeSq() { return this.x * this.x + this.y * this.y; }
	magnitude() { return Math.sqrt(this.magnitudeSq()); }
	normalized() { let mag = this.magnitude(); return new V2(this.x / mag, this.y / mag); }
	static sum(a, b) { return new V2(a.x + b.x, a.y + b.y); }
	static diff(a, b) { return new V2(a.x - b.x, a.y - b.y); }
	static dot(a, b) { return a.x * b.x + a.y * b.y; }
	static prod(a, b) {
		       if (typeof a === "object" && typeof b === "object") {
			return new V2(a.x * b.x, a.y * b.y);
		} else if (typeof a === "object" && typeof b === "number") {
			return new V2(a.x * b, a.y * b);
		} else if (typeof b === "object" && typeof a === "number") {
			return new V2(b.x * a, b.y * a);
		}
		return this;
	}
	static quotient(a, b) {
		       if (typeof a === "object" && typeof b === "object") {
			return new V2(a.x / b.x, a.y / b.y);
		} else if (typeof a === "object" && typeof b === "number") {
			return new V2(a.x / b, a.y / b);
		}
		return this;
	}
}

V2.prototype.toString = function() {
	return "("+this.x+","+this.y+")";
};

class Wire {
	constructor() { }
	draw(ctx) {
		this.drawAlgorithm(ctx);
	}
	drawLine(ctx) {
		ctx.strokeStyle = this.color;
		ctx.lineWidth = this.thickness;
		ctx.beginPath();
		ctx.moveTo(this.start.x, this.start.y);
		ctx.lineTo(this.end.x, this.end.y);
		ctx.stroke();
	}
	drawCircle(ctx) {
		ctx.strokeStyle = this.color;
		ctx.lineWidth = this.thickness;
		ctx.beginPath();
		ctx.arc(this.position.x, this.position.y, this.radius, 0, 2 * Math.PI);
		ctx.stroke();
	}
	line(start, end, color = "black", thickness = 1) {
		this.start = start; this.end = end; this.color = color; this.thickness = thickness;
		this.drawAlgorithm = this.drawLine;
	}
	circle(center, radius, color = "black", thickness = 1) {
		this.position = center; this.radius = radius; this.color = color; this.thickness = thickness;
		this.drawAlgorithm = this.drawCircle;
	}
}

class Wires {
	constructor() {
		this.wires = {};
	}
	make(name) {
		let found = this.wires[name];
		if (found) { return found; }
		found = new Wire()
		found.name = name;
		this.wires[name] = found;
		return found;
	}
	draw(ctx) {
		for (const [key, value] of Object.entries(this.wires)) {
			if (key.hidden) { continue; }
			value.draw(ctx);
		}
	}
}
var WIRES = new Wires();

class BasicSeekBehavior {
	static update (agent, deltaTime) {
		if (!agent.target) { return; }
		//console.log(agent.target, agent.position);
		let delta = V2.diff(agent.target, agent.position);
		WIRES.make(this.name+"currentVelocity").line(agent.position, V2.sum(agent.position, agent.velocity), 'black');
		let distance = delta.magnitude();
		let currentSpeed = agent.velocity.magnitude();
		let breakDistance = currentSpeed*currentSpeed / (2 * agent.acceleration);
		let needToBreak = distance < breakDistance;
		let direction = V2.quotient(delta, distance);
		let desiredVelocity = null;
		agent.stopDistance = breakDistance;
		if (needToBreak) {
			let directionAlignmentWithVelocity = V2.dot(direction, agent.velocity);
			let velocityToRemove = V2.prod(direction, directionAlignmentWithVelocity);
			desiredVelocity = V2.diff(agent.velocity, velocityToRemove);//V2.prod(delta, currentSpeed / distance);// new V2();// V2.prod(direction, breakDistance / currentSpeed);
		} else {
			desiredVelocity = V2.prod(direction, agent.speed);
		}
		let endOfDesiredVelocity = V2.sum(agent.position, desiredVelocity);
		let endOfCurrentVelocityOffset = V2.diff(endOfDesiredVelocity, V2.prod(agent.velocity, agent.acceleration));
		WIRES.make(this.name+"desiredvelocity").line(agent.position, endOfDesiredVelocity, 'blue');
		WIRES.make(this.name+"-currentvelocity").line(endOfDesiredVelocity, endOfCurrentVelocityOffset, 'gray');
		let steeringForce = V2.diff(desiredVelocity, V2.prod(agent.velocity, agent.acceleration));
		WIRES.make(this.name+"steeringVelocity").line(agent.position, V2.sum(agent.position, steeringForce), 'magenta');
		let idealAcceleration = V2.diff(steeringForce, agent.velocity);
		let accelerationMagnitude = idealAcceleration.magnitude();
		let accelerationDirection = V2.quotient(idealAcceleration, accelerationMagnitude);
		let accelerationInOneSecond = V2.prod(accelerationDirection, agent.acceleration);
		let accelerationThisFrame = V2.prod(accelerationInOneSecond, deltaTime);
		//console.log(agent.target, agent.position, "delta:", delta, "dist:", distance, " dir:", direction, " acc:", idealAcceleration, accelerationThisFrame);
		if (agent.velocity) {
			agent.velocity.add(accelerationThisFrame);
		} else {
			agent.velocity = accelerationThisFrame;
		}
		WIRES.make(this.name+"target").circle(agent.target, 2);
	}
}

class Agent {
	constructor(name, x, y, radius, speed, acceleration, strokeColor, fillColor, borderThickness) {
		this.name = name;
		this.position = new V2(x,y);
		this.velocity = new V2(0,0);
		console.log(this.position);
		this.radius = radius;
		this.speed = speed;
		this.acceleration = acceleration;
		this.strokeColor = strokeColor;
		this.fillColor = fillColor;
		this.borderThickness = borderThickness;
		this.behavior = BasicSeekBehavior;
	}

	draw(ctx) {
		ctx.beginPath();
		if (this.strokeColor) {
			ctx.strokeStyle = this.strokeColor;
		}
		ctx.lineWidth = this.borderThickness;
		ctx.arc(this.position.x, this.position.y, this.radius, 0, 2 * Math.PI);
		if (this.fillColor) {
			ctx.fillStyle = this.fillColor;
			ctx.fill();
		}
		ctx.moveTo(this.position.x, this.position.y);
		let endPoint = V2.sum(this.position, this.velocity);
		ctx.lineTo(endPoint.x, endPoint.y);
		ctx.stroke();
		if (this.stopDistance) {
			let moveDir = this.velocity.normalized();
			let stopVector = V2.prod(moveDir, this.stopDistance);
			let stopPosition = V2.sum(this.position, stopVector);
			ctx.beginPath();
			ctx.fillStyle = undefined;
			ctx.arc(stopPosition.x, stopPosition.y, this.radius, 0, 2 * Math.PI);
			ctx.stroke();
		}
		WIRES.draw(ctx);
	}

	update(deltaTime) {
		if (this.behavior) {
			this.behavior.update(this, deltaTime);
		} else {
			if (this.target) {
				let delta = V2.diff(this.target, this.position);
				let distance = delta.magnitude();
				if (distance < this.radius) {
					this.velocity = new V2(0,0);
				}
			}
		}
		if (this.velocity) {
			let movedThisFrame = V2.prod(this.velocity, deltaTime);
			//console.log(this.position, movedThisFrame);
			this.position.add(movedThisFrame);
		}
	}

	setTarget(x, y) {
		this.target = new V2(x, y);
		// let delta = V2.diff(this.target, this.position);
		// let distance = delta.magnitude();
		// let direction = V2.quotient(delta, distance);
		// this.velocity = V2.prod(direction, this.speed);
		console.log(this.fillColor, this.target, this.position);
	}

	setEndOfLine(x, y) {
		this.setTarget(x, y);
	}
};

APP = new App();
agents = [
	new Agent("Red", 100, 100, 10, 100, 5, 'orange', 'red', 0.25),
	//new Agent("Bluey", 0, 0, 20, 50, 20, 'cyan', 'blue', 0.25),
];
WIRES.make("test").line(new V2(50,50), new V2(200,60), 'red');
		</script>
		<br>
		could we implement <a href="https://www.red3d.com/cwr/steer/gdc99/">steering</a>
		<a href="https://devforum.roblox.com/t/introduction-to-steering-behaviors/1441680/6">behavior</a>
		for our agent?
	</body>
</html>
