<!DOCTYPE html>
<html>
	<head>
	<style>
		body { margin:0; padding:0; }
	</style>
	</head>
	<body onload="mainLoop()" onmousemove="mouseMoveInterrupt()" onkeydown="keyDownInterrupt()" onmousedown="mouseDownInterrupt()">
		<script>
var APP;
var agents;
var getPlayer = () => agents[0];
function forEachAgent(whatToDo) {
	for (let i = 0; i < agents.length; i++) {
		whatToDo(agents[i]);
	}
}

function mainLoop() {
	APP.processInput();
	APP.update();
	APP.drawGame();
	setTimeout(mainLoop, 10);
}

function mouseMoveInterrupt(e) {
	APP.updateMousePosition(e || window.event);
}

function keyDownInterrupt(e) {
	APP.updateKeyInput(e || window.event);
}

function mouseDownInterrupt(e) {
	APP.updateMouseDownInput(e || window.event);
}

class App {
	constructor() {
		this.canvas = document.createElement("canvas"),
		this.now = Date.now();
		console.log("creating "+this.now);
		this.then = Date.now();
		this.targetFps = 90;
		this.mouse = {x: 0, y: 0};
		this.canvas.width = 800;
		this.canvas.height = 600;
		this.context = this.canvas.getContext("2d");
		document.body.insertBefore(this.canvas, document.body.childNodes[0]);
		document.onkeydown = this.userkey;
	}

	updateKeyInput(e) {
		const ESCAPE = 27;
		if (e.keyCode === ESCAPE) {
			this.clearScreen = true;
		} else {
			console.log("key: "+e.keyCode)
		}
	};

	updateMousePosition(e) {
		if (!e) {
			return;
		}
		this.mouse.x = e.clientX;
		this.mouse.y = e.clientY;
	}

	updateMouseDownInput(e) {
		this.updateMousePosition(e);
		console.log("clicked " + this.mouse.x + " " + this.mouse.y);
		var player = getPlayer();
		player.setEndOfLine(this.mouse.x, this.mouse.y);
	}

	processInput() {
		if (this.mouse) {
		}
		if (this.clearScreen) {
			this.clear();
			this.clearScreen = false;
		}
	}

	drawGame() {
		//this.clear();
		this.ctx = this.canvas.getContext("2d");
		this.ctx.font = "30px Arial";
		this.ctx.fillStyle = "#0f0";
		this.ctx.textAlign = "center";
		this.ctx.fillText("Hello World!", this.canvas.width / 2, this.canvas.height / 2);
		forEachAgent(a => a.draw(this.ctx));
	}

	update() {
		this.updateTiming();
		let timeHasPassed = this.deltaTime > 0;
		if (timeHasPassed) { 
			let deltatime = this.deltaTime / 1000;
			forEachAgent(a => a.update(deltatime));
		}
	}

	updateTiming() {
		this.now = Date.now();
		let deltaTime = this.now - this.then;
		if (deltaTime) { 
			this.deltaTime = deltaTime;
		}
		this.then = this.now;
	}

	clear() {
		this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
	}
};

class V2 {
	constructor(x = 0, y = 0) { this.x = x; this.y = y; }
	add(v) { this.x += v.x; this.y += v.y; return this; }
	sub(v) { this.x -= v.x; this.y -= v.y; return this; }
	mul(v) {
		if (typeof v === "object") {
			this.x *= v.x;
			this.y *= v.y;
		} else if (typeof v === "number") {
			this.x *= v;
			this.y *= v;
		}
		return this;
	}
	div(v) {
		if (typeof v === "object") {
			this.x /= v.x;
			this.y /= v.y;
		} else if (typeof v === "number") {
			this.x /= v;
			this.y /= v;
		}
		return this;
	}
	magnitudeSq() { return this.x * this.x + this.y * this.y; }
	magnitude() { return Math.sqrt(this.magnitudeSq()); }
	static sum(a, b) { return new V2(a.x + b.x, a.y + b.y); }
	static diff(a, b) { return new V2(a.x - b.x, a.y - b.y); }
	static prod(a, b) {
		       if (typeof a === "object" && typeof b === "object") {
			return new V2(a.x * b.x, a.y * b.y);
		} else if (typeof a === "object" && typeof b === "number") {
			return new V2(a.x * b, a.y * b);
		} else if (typeof b === "object" && typeof a === "number") {
			return new V2(b.x * a, b.y * a);
		}
		return this;
	}
	static quotient(a, b) {
		       if (typeof a === "object" && typeof b === "object") {
			return new V2(a.x / b.x, a.y / b.y);
		} else if (typeof a === "object" && typeof b === "number") {
			return new V2(a.x / b, a.y / b);
		}
		return this;
	}
}

V2.prototype.toString = function() {
	return "("+this.x+","+this.y+")";
};

class Agent {
	constructor(x, y, radius, speed, acceleration, strokeColor, fillColor, borderThickness) {
		this.position = new V2(x,y);
		this.velocity = new V2(0,0);
		this.radius = radius;
		this.speed = speed;
		this.acceleration = acceleration;
		this.strokeColor = strokeColor;
		this.fillColor = fillColor;
		this.borderThickness = borderThickness;
	}

	draw(ctx) {
		ctx.beginPath();
		if (this.strokeColor) {
			ctx.strokeStyle = this.strokeColor;
		}
		ctx.lineWidth = this.borderThickness;
		ctx.arc(this.position.x, this.position.y, this.radius, 0, 2 * Math.PI);
		if (this.fillColor) {
			ctx.fillStyle = this.fillColor;
			ctx.fill();
		}
		ctx.moveTo(this.position.x, this.position.y);
		let endPoint = V2.sum(this.position, this.velocity);
		ctx.lineTo(endPoint.x, endPoint.y);
		ctx.stroke();
	}

	update(deltaTime) {
		let movedThisFrame = V2.prod(this.velocity, deltaTime);
		this.position.add(movedThisFrame);
		if (this.target) {
			let delta = V2.diff(this.target, this.position);
			let distance = delta.magnitude();
			if (distance < this.radius) {
				this.velocity = new V2();
			}
		}
	}

	setTarget(x, y) {
		this.target = new V2(x, y);
		let delta = V2.diff(this.target, this.position);
		let distance = delta.magnitude();
		let direction = V2.quotient(delta, distance);
		this.velocity = V2.prod(direction, this.speed);
	}

	setEndOfLine(x, y) {
		this.setTarget(x, y);
	}
};


APP = new App();
agents = [
	new Agent(100, 100, 20, 100, 5, 'orange', 'red', 0.25),
	new Agent(0,   0,   20, 50, 20, 'cyan', 'blue', 0.25)
];

		</script>
		<br>
		could we implement <a href="https://www.red3d.com/cwr/steer/gdc99/">steering</a>
		<a href="https://devforum.roblox.com/t/introduction-to-steering-behaviors/1441680/6">behavior</a>
		for our agent?
	</body>
</html>
