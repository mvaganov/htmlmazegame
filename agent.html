<!DOCTYPE html>
<html>
	<head>
	<style>
		body { margin:0; padding:0; }
	</style>
	</head>
	<body onload="mainLoop()" onmousemove="mouseMoveInterrupt()" onkeydown="keyDownInterrupt()" onmousedown="mouseDownInterrupt()">
		<script>
var APP;
var agents;
var getPlayer = () => agents[0];
var drawList = [];

function forEachAgent(whatToDo) {
	for (let i = 0; i < agents.length; i++) {
		whatToDo(agents[i]);
	}
}

function mainLoop() {
	APP.processInput();
	APP.update();
	APP.drawGame();
	setTimeout(mainLoop, APP.frameDelay);
}

class App {
	constructor() {
		this.canvas = document.createElement("canvas");
		this.now = Date.now();
		console.log("creating "+this.now);
		this.then = Date.now();
		this.targetFps = 30;
		this.frameDelay = 1000/this.targetFps;
		this.mouse = {x: 0, y: 0};
		this.canvas.width = 800;
		this.canvas.height = 600;
		this.context = this.canvas.getContext("2d");
		document.body.insertBefore(this.canvas, document.body.childNodes[0]);
		document.onkeydown = this.userkey;
	}

	updateKeyInput(e) {
		const ESCAPE = 27;
		if (e.keyCode === ESCAPE) {
			this.clearScreen = true;
		} else {
			console.log("key: "+e.keyCode)
		}
	};

	updateMousePosition(e) {
		if (!e) {
			return;
		}
		this.mouse.x = e.clientX;
		this.mouse.y = e.clientY;
	}

	updateMouseDownInput(e) {
		this.updateMousePosition(e);
		forEachAgent(a => a.setEndOfLine(this.mouse.x, this.mouse.y));
	}

	processInput() {
		if (this.mouse) {
		}
		if (this.clearScreen) {
			this.clear();
			this.clearScreen = false;
		}
	}

	drawGame() {
		this.clear();
		this.ctx = this.canvas.getContext("2d");
		this.ctx.font = "30px Arial";
		this.ctx.fillStyle = "#0f0";
		this.ctx.textAlign = "center";
		this.ctx.fillText("Hello World!", this.canvas.width / 2, this.canvas.height / 2);
		forEachAgent(a => a.draw(this.ctx));
	}

	update() {
		this.updateTiming();
		let timeHasPassed = this.deltaTime > 0;
		if (timeHasPassed) { 
			let deltatime = this.deltaTime / 1000;
			forEachAgent(a => a.update(deltatime));
		}
	}

	updateTiming() {
		this.now = Date.now();
		let deltaTime = this.now - this.then;
		if (deltaTime) { 
			this.deltaTime = deltaTime;
		}
		this.then = this.now;
	}

	clear() {
		this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
	}
};

class V2 {
	constructor(x = 0, y = 0) {
		this.x = x; this.y = y;
		this.assert();
	}
	assert() { if (this.x == undefined || this.y == undefined) { throw new Error("undefined values! " + this.toString()); } }
	add(v) { this.x += v.x; this.y += v.y; this.assert(); return this; }
	sub(v) { this.x -= v.x; this.y -= v.y; this.assert(); return this; }
	mul(v) {
		       if (typeof v === "object") {
			this.x *= v.x; this.y *= v.y;
		} else if (typeof v === "number") {
			this.x *= v; this.y *= v;
		}
		this.assert();
		return this;
	}
	div(v) {
		       if (typeof v === "object") {
			this.x /= v.x; this.y /= v.y;
		} else if (typeof v === "number") {
			this.x /= v; this.y /= v;
		}
		this.assert();
		return this;
	}
	magnitudeSq() { return this.x * this.x + this.y * this.y; }
	magnitude() { return Math.sqrt(this.magnitudeSq()); }
	normalized() { let mag = this.magnitude(); return new V2(this.x / mag, this.y / mag); }
	static sum(a, b) { return new V2(a.x + b.x, a.y + b.y); }
	static diff(a, b) { return new V2(a.x - b.x, a.y - b.y); }
	static dot(a, b) { return a.x * b.x + a.y * b.y; }
	static isNan(v) { return !v.x || !v.y; }
	static prod(a, b) {
		       if (typeof a === "object" && typeof b === "object") {
			return new V2(a.x * b.x, a.y * b.y);
		} else if (typeof a === "object" && typeof b === "number") {
			return new V2(a.x * b, a.y * b);
		} else if (typeof b === "object" && typeof a === "number") {
			return new V2(b.x * a, b.y * a);
		}
		throw "can't multiply "+(typeof a)+" and "+(typeof b);
	}
	static quotient(a, b) {
		       if (typeof a === "object" && typeof b === "object") {
			return new V2(a.x / b.x, a.y / b.y);
		} else if (typeof a === "object" && typeof b === "number") {
			return new V2(a.x / b, a.y / b);
		}
		return this;
	}
	static lerp(a, b, p) {
		let dx = b.x - a.x;
		let dy = b.y - a.y;
		return new V2(a.x + (dx * p), a.y + (dy * p));
	}
}

V2.prototype.toString = function() {
	return "("+this.x+","+this.y+")";
};

class Wire {
	constructor() { }
	draw(ctx) {
		this.drawAlgorithm(ctx);
	}
	drawLine(ctx) {
		ctx.strokeStyle = this.color;
		ctx.lineWidth = this.thickness;
		ctx.beginPath();
		ctx.moveTo(this.start.x, this.start.y);
		ctx.lineTo(this.end.x, this.end.y);
		ctx.stroke();
	}
	drawCircle(ctx) {
		ctx.strokeStyle = this.color;
		ctx.lineWidth = this.thickness;
		ctx.beginPath();
		ctx.arc(this.position.x, this.position.y, this.radius, 0, 2 * Math.PI);
		ctx.stroke();
	}
	line(start, end, color = "black", thickness = 1) {
		this.start = start; this.end = end; this.color = color; this.thickness = thickness;
		this.drawAlgorithm = this.drawLine;
	}
	circle(center, radius, color = "black", thickness = 1) {
		this.position = center; this.radius = radius; this.color = color; this.thickness = thickness;
		this.drawAlgorithm = this.drawCircle;
	}
}

class Wires {
	constructor() {
		this.wires = {};
	}
	make(name) {
		let found = this.wires[name];
		if (found) { return found; }
		found = new Wire()
		found.name = name;
		this.wires[name] = found;
		return found;
	}
	draw(ctx) {
		for (const [key, value] of Object.entries(this.wires)) {
			if (key.hidden) { continue; }
			value.draw(ctx);
		}
	}
}
var WIRES = new Wires();
var DOT_TEST = 0;

class BasicSeekBehavior {
	static update (agent, deltaTime) {
		if (!agent.target) { return; }
		//console.log(agent.target, agent.position);
		WIRES.make(agent.name+"target").circle(agent.target, 2);
		WIRES.make(agent.name+"currentVelocity").line(agent.position, V2.sum(agent.position, agent.velocity), 'black');
		let targetDelta = V2.diff(agent.target, agent.position);
		let targetDistance = targetDelta.magnitude();
		let targetDirection = V2.quotient(targetDelta, targetDistance);
		let currentSpeed = agent.velocity.magnitude();
		let velocityDirection = V2.quotient(agent.velocity, currentSpeed);
		let brakeDistance = currentSpeed*currentSpeed / (2 * agent.acceleration);
		let stoppingVector = V2.prod(velocityDirection, brakeDistance);

		let brakePosition = V2.sum(agent.position, stoppingVector);
		WIRES.make(agent.name+"brakedistance").line(agent.position, brakePosition, 'red');

		//console.log(stoppingVector);

		let currentExpectedMovement = agent.velocity;
		if (currentSpeed > 0) {
			currentExpectedMovement = stoppingVector;
		}

		let desiredVelocityLookAhead = agent.speed;

		let desiredVelocity = V2.prod(targetDirection, agent.speed);

		// TODO if we want to hit the brakes, set the desired velocity to zero... and find out what turns NaN!
		let stopping = false;
		if (brakeDistance > 0 && brakeDistance > targetDistance) {
			let alignmentWithBrakes = V2.dot(targetDirection, velocityDirection);
			if (alignmentWithBrakes > 0) {
				WIRES.make("STOP").circle(agent.position, agent.radius + 3, 'red');
				desiredVelocity = new V2(0,0);
				stopping = true;
			} else {
				WIRES.make("STOP").circle(agent.position, agent.radius + 3, 'white');
			}
		}

		let desiredSteeringForce = V2.diff(desiredVelocity, currentExpectedMovement);
		let brakeColor = 'green';
		let whereAmIGoing = desiredVelocity;
		if (brakeDistance > 0 && brakeDistance > targetDistance) {
			desiredSteeringForce = V2.diff(new V2(0,0), currentExpectedMovement);
			if (V2.isNan(desiredSteeringForce)) {
				console.log(agent.name+" bad desiredSteeringForce "+desiredSteeringForce);
			}
			brakeColor = 'red';
			whereAmIGoing = new V2(0,0);
		}
		WIRES.make(agent.name+"brakeposition").circle(brakePosition, agent.radius, brakeColor);

		if (!stopping && brakeDistance > 0) {
			whereAmIGoing = V2.prod(targetDirection, brakeDistance);
			let hardSteeringForce = V2.diff(whereAmIGoing, currentExpectedMovement);
			//let avg = V2.quotient(V2.sum(desiredVelocity, hardSteeringForce), 2);
			let howAlignedIsVelocityAndTargetDirection = V2.dot(targetDirection, velocityDirection);
			const dotIsCloseEnough = 15/16;
			let steeringWasTheSameLastFrame = agent.lastSteeringForce != undefined && V2.dot(hardSteeringForce, desiredVelocity) > dotIsCloseEnough;
			if (howAlignedIsVelocityAndTargetDirection < 0.9//currentSpeed / agent.speed
			|| (steeringWasTheSameLastFrame && currentSpeed > 20)) {
				howAlignedIsVelocityAndTargetDirection = 0;
			}
			// the less aligned the directions, the more hard-steering will be done to get on course.
			desiredSteeringForce = V2.lerp(hardSteeringForce, desiredVelocity, howAlignedIsVelocityAndTargetDirection);
			agent.lastSteeringForce = desiredSteeringForce;
		}

		let velocityEndPoint = V2.sum(agent.position, desiredVelocity);
		let whereAmIGoingEndPoint = V2.sum(agent.position, whereAmIGoing);
		WIRES.make(agent.name+"desiredVelocity").line(agent.position, velocityEndPoint, 'blue');
		WIRES.make(agent.name+"currentVelocity").line(whereAmIGoingEndPoint, V2.diff(whereAmIGoingEndPoint, currentExpectedMovement), 'gray');

		let steeringDirection = desiredSteeringForce.normalized();
		let actualSteeringForce = V2.prod(steeringDirection, agent.acceleration);

		WIRES.make(agent.name+"steeringforce").line(agent.position, V2.sum(agent.position, actualSteeringForce), 'magenta');

		let accelerationThisFrame = V2.prod(actualSteeringForce, deltaTime);
		if (agent.velocity) {
			agent.velocity.add(accelerationThisFrame);
		} else {
			agent.velocity = accelerationThisFrame;
		}
		currentSpeed = agent.velocity.magnitude();
		if (currentSpeed > agent.speed) {
			velocityDirection = V2.quotient(agent.velocity, currentSpeed);
			agent.velocity = V2.prod(velocityDirection, agent.speed);
		}
		return;
	}
}

class Agent {
	constructor(name, x, y, radius, speed, acceleration, strokeColor, fillColor, borderThickness) {
		this.name = name;
		this.position = new V2(x,y);
		this.velocity = new V2(0,0);
		console.log(this.position);
		this.radius = radius;
		this.speed = speed;
		this.acceleration = acceleration;
		this.strokeColor = strokeColor;
		this.fillColor = fillColor;
		this.borderThickness = borderThickness;
		this.behavior = BasicSeekBehavior;
	}

	draw(ctx) {
		ctx.beginPath();
		if (this.strokeColor) {
			ctx.strokeStyle = this.strokeColor;
		}
		ctx.lineWidth = this.borderThickness;
		ctx.arc(this.position.x, this.position.y, this.radius, 0, 2 * Math.PI);
		if (this.fillColor) {
			ctx.fillStyle = this.fillColor;
			ctx.fill();
		}
		ctx.moveTo(this.position.x, this.position.y);
		let endPoint = V2.sum(this.position, this.velocity);
		ctx.lineTo(endPoint.x, endPoint.y);
		ctx.stroke();
		if (this.stopDistance) {
			let moveDir = this.velocity.normalized();
			let stopVector = V2.prod(moveDir, this.stopDistance);
			let stopPosition = V2.sum(this.position, stopVector);
			ctx.beginPath();
			ctx.fillStyle = undefined;
			ctx.arc(stopPosition.x, stopPosition.y, this.radius, 0, 2 * Math.PI);
			ctx.stroke();
		}
		WIRES.draw(ctx);
	}

	update(deltaTime) {
		if (this.behavior) {
			this.behavior.update(this, deltaTime);
		} else {
			if (this.target) {
				let delta = V2.diff(this.target, this.position);
				let distance = delta.magnitude();
				if (distance < this.radius) {
					this.velocity = new V2(0,0);
				}
			}
		}
		if (this.velocity) {
			let movedThisFrame = V2.prod(this.velocity, deltaTime);
			//console.log(this.position, movedThisFrame);
			this.position.add(movedThisFrame);
		}
	}

	setTarget(x, y) {
		this.target = new V2(x, y);
		//console.log(this.fillColor, this.target, this.position);
	}

	setEndOfLine(x, y) {
		this.setTarget(x, y);
	}
};

APP = new App();
agents = [
	new Agent("Red", 100, 100, 10, 200, 20, 'orange', 'red', 0.25),
	new Agent("Bluey", 0, 0, 20, 50, 100, 'cyan', 'blue', 0.25),
];

let testA = new V2(50,50);
let testB = new V2(200,60);
let testP = 0;
WIRES.make("test").line(testA, testB, 'red');

function mouseMoveInterrupt(e) {
	APP.updateMousePosition(e || window.event);
}

function keyDownInterrupt(e) {
	APP.updateKeyInput(e || window.event);
	if (!e) { e = window.event; }
	if (e.keyCode === 187) { // =
		testP += 1/8;
	}
	if (e.keyCode === 189) { // -
		testP -= 1/8;
	}
	let lerped = V2.lerp(testA, testB, testP);
	console.log(testP);
	WIRES.make("test circle").circle(lerped, 5);
}

function mouseDownInterrupt(e) {
	APP.updateMouseDownInput(e || window.event);
}
		</script>
		<br>
		could we implement <a href="https://www.red3d.com/cwr/steer/gdc99/">steering</a>
		<a href="https://devforum.roblox.com/t/introduction-to-steering-behaviors/1441680/6">behavior</a>
		for our agent?
	</body>
</html>
