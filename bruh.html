<!DOCTYPE html>
<html>
	<head>
	<style>
		body { margin:0; padding:0; }
	</style>
	</head>
	<body onload="mainLoop()" onmousemove="mouseMoveInterrupt()" onkeydown="keyDownInterrupt()" onmousedown="mouseDownInterrupt()">
		<script>
// -10 wtf			
// -2 bruh
// -1 kek
// 0 ...
// 1 heh
// 2 hah
// 3 ha ha
// 4 haha
// 5 lol
// 6 haha lol
// 7 ahaha
// 8 rofl
// 9 lololol
// 10 omgroflhahaha

// 0 ...
// 5 that's funny.
// 8 bro that's really good.
// 10 dude you are hilarious.

// presentation/delivery - confidence, tone of voice, consistency and legibility of speech
// categoryA - poitics
// categoryB - sex
// categoryC - relationships
// categoryD - prejudice and other cognitive biases
// prophecy - saying what other people wish they had thought of

// comedian type
// * coincidental - the coincidental comedian sees something, reads something or hears something and turns it into a joke in that moment.
// * architect
// * humorost

// laughter triggers:
// - Surprise
//     Surprise or Twist: Many jokes rely on surprising the audience with an unexpected punchline or twist. The element of surprise can catch people off guard and generate laughter.
// - Superiority
//     Laughing at the misfortune of others
// - Embarrassment
//     make the audience feel embarassed and laugh as a coping mechanism
// - Incongruity
//     Incongruity: Jokes often involve bringing together seemingly unrelated or incompatible elements, creating a contrast that triggers laughter. The unexpected combination can be funny.
// - Recognition
// - Release
//     At least nobody died.
// - Configurational
// - Ambivalence
// - Coincidence
// - Benign Violations
//     it's bad but harmless. Tragedy + Time


// Timing: Timing is crucial in comedy. The delivery of a joke, including pauses and pacing, can significantly impact its comedic effect. Well-timed punchlines tend to be funnier.
// Relatability: Jokes that touch on shared experiences or common situations are often funnier because people can relate to them. Understanding the context allows individuals to connect with the humor.
// Wordplay and Puns: Clever wordplay, puns, and linguistic humor can be amusing. Playing with language, double meanings, or creating unexpected connections between words can elicit laughter.
// Exaggeration: Overstating or exaggerating situations, characteristics, or behaviors can be humorous. It often involves taking something to an extreme, making it absurd and comical.
// Observational Comedy: Comedians often find humor in everyday situations by providing a unique or humorous perspective on common experiences, highlighting the absurdities in daily life.
// Satire and Irony: Satirical humor involves mocking or ridiculing people, institutions, or societal norms. Irony, where there is a contrast between expectations and reality, can also be comedic.
// Self-Deprecation: Jokes that involve poking fun at oneself or one's own flaws can be relatable and endearing. It creates a sense of humility that resonates with audiences.
// Cultural and Social Context: Understanding cultural references and social context is crucial for some jokes. Humor that taps into shared cultural knowledge can be more effective within specific groups.
const WORLD_WIDTH = 800;
const WORLD_HEIGHT = 600;
let DRAWMATH = false;
var APP;
var agents;
var getPlayer = () => agents[0];
var drawList = [];

var collisionHappening = function (agent) {
	let listOfCollisions = null;
	let agentCircle = Agent.getCircle(agent);
	let collidingAgents = spacePartition.getCollisions(agentCircle, Agent.getCircle);
	if (!collidingAgents || collidingAgents.length == 0) {
		return null;
	}
	for (let i = 0; i < collidingAgents.length; i++) {
		let a = collidingAgents[i];
		if (a == agent) { continue; }
		let collisionData = Agent.collision(agent, a);
		if (collisionData != null) {
			if (listOfCollisions == null) {
				listOfCollisions = [collisionData];
			} else {
				listOfCollisions.push(collisionData);
			}
		}
	}

	return listOfCollisions;
}

function forEachAgent(whatToDo) {
	for (let i = 0; i < agents.length; i++) {
		whatToDo(agents[i]);
	}
}

function mainLoop() {
	APP.processInput();
	APP.update();
	APP.drawGame();
	setTimeout(mainLoop, APP.frameDelay);
}

class V2 {
	constructor(x = 0, y = undefined) {
		if (x === 0 && y === undefined) {
			this.x = 0; this.y = 0;
		} else if (y === undefined && typeof x === "object") {
			this.x = x.x; this.y = x.y;
		} else {
			this.x = x; this.y = y;
		}
		this.assert();
	}
	isZero() { return this.x === 0 && this.y === 0; }
	assert() { if (this.x === undefined || this.y === undefined) { throw new Error("undefined values! " + this.toString()); } }
	set(x,y) { this.x = x; this.y = y; this.assert(); return this; }
	copy(v) { this.x = v.x; this.y = v.y; this.assert(); return this; }
	add(v) { this.x += v.x; this.y += v.y; this.assert(); return this; }
	sub(v) { this.x -= v.x; this.y -= v.y; this.assert(); return this; }
	mul(v) {
		       if (typeof v === "object") {
			this.x *= v.x; this.y *= v.y;
		} else if (typeof v === "number") {
			this.x *= v; this.y *= v;
		}
		this.assert();
		return this;
	}
	div(v) {
		       if (typeof v === "object") {
			this.x /= v.x; this.y /= v.y;
		} else if (typeof v === "number") {
			this.x /= v; this.y /= v;
		}
		this.assert();
		return this;
	}
	magnitudeSq() { return this.x * this.x + this.y * this.y; }
	magnitude() { return Math.sqrt(this.magnitudeSq()); }
	normalized() { let mag = this.magnitude(); return new V2(this.x / mag, this.y / mag); }
	area() { return this.x*this.y; }
	static sum(a, b) { return new V2(a.x + b.x, a.y + b.y); }
	static diff(a, b) { return new V2(a.x - b.x, a.y - b.y); }
	static dot(a, b) { return a.x * b.x + a.y * b.y; }
	static sign(a, b) { return a.x * b.y - a.y * b.x; }
	static isNan(v) { return !v.x || !v.y; }
	static prod(a, b) {
		       if (typeof a === "object" && typeof b === "object") {
			return new V2(a.x * b.x, a.y * b.y);
		} else if (typeof a === "object" && typeof b === "number") {
			return new V2(a.x * b, a.y * b);
		} else if (typeof b === "object" && typeof a === "number") {
			return new V2(b.x * a, b.y * a);
		}
		throw "can't multiply "+(typeof a)+" and "+(typeof b);
	}
	static quotient(a, b) {
		       if (typeof a === "object" && typeof b === "object") {
			return new V2(a.x / b.x, a.y / b.y);
		} else if (typeof a === "object" && typeof b === "number") {
			return new V2(a.x / b, a.y / b);
		}
		return this;
	}
	static lerp(a, b, p) {
		let dx = b.x - a.x;
		let dy = b.y - a.y;
		return new V2(a.x + (dx * p), a.y + (dy * p));
	}
	static distance(a, b) {
		let x = a.x-b.x;
		let y = a.y-b.y;
		return Math.sqrt(x*x+y*y);
	}
}

V2.prototype.toString = function() {
	return "("+this.x+","+this.y+")";
};

class AABB {
	constructor(min, max) { this.min = min; this.max = max; }
	static isInside(v, min, max) { return v.x < max.x && v.y < max.y && v.x >= min.x && v.y >= min.y; }
	size() { return new V2(this.max.x-this.min.x, this.max.y-this.min.y); }
	area() { return this.size().area(); }
	contains(v) { return AABB.isInside(v, this.min, this.max); }
	getCenter() { return new V2((this.min.x+this.max.x)/2, (this.min.y+this.max.y)/2); }
	intersectsCircle(center, radius) {
		if (this.contains(center)) { return true; }
		let radSize = new V2(radius,radius);
		let expandedMin = V2.diff(this.min, radSize);
		let expandedMax = V2.sum(this.max, radSize);
		if (AABB.isInside(center, expandedMin, expandedMax)) {
			let cornerCase = undefined;
			if (center.x < this.min.x) {
				if (center.y < this.min.y) {
					cornerCase = this.min;
				} else if (center.y > this.max.y) {
					cornerCase = new V2(this.min.x, this.max.y);
				}
			} else if (center.x > this.max.x) {
				if (center.y < this.min.y) {
					cornerCase = new V2(this.max.x, this.min.y);
				} else if (center.y > this.max.y) {
					cornerCase = this.max;
				}
			}
			if (cornerCase) {
				let distance = V2.distance(cornerCase, center);
				return distance <= radius;
			}
			return true;
		}
		return false;
	}
	intersectsRect(otherMin, otherMax) {
		if (this.min.x > otherMax.x || otherMin.x > this.max.x || this.max.y > otherMin.y || otherMax.y > this.min.y) {
			return false;
		}
		if (this.min.x == this.max.x || this.min.y == this.max.y || otherMax.x == otherMin.x || otherMin.y == otherMax.y) {
			return false;
		}
		return true;
	}
	draw(ctx) {
		let size = this.size();
		ctx.beginPath();
		ctx.rect(this.min.x, this.min.y, size.x, size.y);
		ctx.stroke();
	}
}

AABB.prototype.toString = function() {
	return "(" + this.min.x + "," + this.min.y + ":" + this.max.x + "," + this.max.y + ")";
};

class Circle {
	constructor(center, radius) {
		this.center = center;
		this.radius = radius;
	}
}

Circle.prototype.toString = function() {
	return "(" + this.center.x.toFixed(2) + "," + this.center.y.toFixed(2) + ":" + this.radius.toFixed(2) + ")";
};

class SpacePartition {
	constructor(min, max, minArea, columnsRows, parent = undefined) {
		this.aabb = new AABB(new V2(min), new V2(max));
		this.list = [];
		this.columnsRows = columnsRows;
		this.depth = 0;
		this.parent = parent;
		while(parent) {
			++this.depth;
			parent = parent.parent;
		}
		if (this.depth > 3) {
			return;
		}
		this.createSubPartition(minArea);
	}

	createSubPartition(minArea) {
		let columns = this.columnsRows.x;
		let rows = this.columnsRows.y;
		let size = this.aabb.size();
		let cellSize = new V2(size.x / columns, size.y / rows)
		let cellArea = cellSize.area();
		if (cellArea < minArea) {
			return;
		}
		this.subpartition = [];
		let cursor = new V2(this.aabb.min);
		for(let r = 0; r < rows; ++r) {
			cursor.x = this.aabb.min.x;
			for(let c = 0; c < columns; ++c) {
				let nextCell = new SpacePartition(cursor, V2.sum(cursor, cellSize), minArea, this.columnsRows, this);
				this.subpartition.push(nextCell);
				cursor.x += cellSize.x;
			}
			cursor.y += cellSize.y;
		}
	}

	draw(ctx, drawElementFunction) {
		this.aabb.draw(ctx);
		if (this.subpartition) {
			for(let i = 0; i < this.subpartition.length; i++) {
				this.subpartition[i].draw(ctx, drawElementFunction);
			}
		}
		let center = this.aabb.getCenter();
		//ctx.fillText(""+this.list.length, center.x, center.y);
		if (drawElementFunction){
			for (let i = 0; i < this.list.length; ++i) {
				let element = this.list[i];
				drawElementFunction(ctx, this, element);
			}
		}
	}

	getPartitions(circle) {
		if (!this.subpartition) {
			return [this];
		}
		let totalFoundPartitions = undefined;
		for(let i = 0; i < this.subpartition.length; i++) {
			let subPartition = this.subpartition[i];
			if (circle.radius) {
				if (!subPartition.aabb.intersectsCircle(circle.center, circle.radius)) { continue; }
			} else {
				if (!subPartition.aabb.contains(circle.center)) { continue; }
			}
			let foundPartitions = subPartition.getPartitions(circle);
			if (foundPartitions) {
				if (!totalFoundPartitions) { totalFoundPartitions = []; }
				totalFoundPartitions = totalFoundPartitions.concat(foundPartitions);
			}
		}
		if (totalFoundPartitions === undefined) {
			totalFoundPartitions = [this];
		}
		return totalFoundPartitions;
	}

	clearList() {
		this.list = [];
		if (this.subpartition) {
			for(let i = 0; i < this.subpartition.length; i++) {
				this.subpartition[i].clearList();
			}
		}
	}

	populate(list, convertElementToCircleMethod) {
		this.clearList();
		for (let i = 0; i < list.length; ++i) {
			let element = list[i];
			let circle = convertElementToCircleMethod(element);
			let partitions = this.getPartitions(circle);
			//console.log(element.name+" in "+partitions.length+" partitions: "+partitions[0].aabb);
			for (let p = 0; p < partitions.length; ++p) {
				let partition = partitions[p];
				partition.list.push(element);
			}
		}
	}

	getCollisions(circle, convertElementToCircleMethod) {
		let partitions = this.getPartitions(circle);
		//console.log(partitions.length);
		let collisions = undefined;
		for (let i = 0; i < partitions.length; ++i) {
			//console.log(partitions[i].list.length);
			for (let e = 0; e < partitions[i].list.length; ++e) {
				let element = partitions[i].list[e];
				if (!element) { continue; }
				let otherCircle = convertElementToCircleMethod(element);
				let targetDistance = otherCircle.radius;
				if (circle.radius) {
					targetDistance += circle.radius;
				}
				let distance = V2.distance(circle.center, otherCircle.center);
				if (distance <= targetDistance) {
					if (!collisions) { collisions = []; }
					collisions.push(element);
				}
			}
		}
		return collisions;
	}
}

let spacePartition = new SpacePartition(new V2(0,0), new V2(WORLD_WIDTH, WORLD_HEIGHT), WORLD_WIDTH*WORLD_HEIGHT/64, new V2(2,2));

class App {
	constructor() {
		this.canvas = document.createElement("canvas");
		this.now = Date.now();
		console.log("creating " + this.now);
		this.then = Date.now();
		this.targetFps = 30;
		this.frameDelay = 1000 / this.targetFps;
		this.mouse = new V2(0,0);
		this.canvas.width = WORLD_WIDTH;
		this.canvas.height = WORLD_HEIGHT;
		this.context = this.canvas.getContext("2d");
		document.body.insertBefore(this.canvas, document.body.childNodes[0]);
		document.onkeydown = this.userkey;
	}

	updateKeyInput(e) {
		const ESCAPE = 27;
		if (e.keyCode === ESCAPE) {
			this.clearScreen = true;
		} else {
			console.log("key: " + e.keyCode)
		}
	};

	updateMousePosition(e) {
		if (!e) {
			return;
		}
		this.mouse.set(e.clientX, e.clientY);
	}

	updateMouseDownInput(e) {
		this.updateMousePosition(e);
		forEachAgent(a => a.setEndOfLine(this.mouse.x, this.mouse.y));
	}

	processInput() {
		if (this.mouse) {
			forEachAgent(a => a.selectionState = STATE_NONE);
			forEachAgent(a => {
				if(a.contains(this.mouse)) {
					a.selectionState = STATE_HOVERED;
				}
			});
		}
		if (this.clearScreen) {
			this.clear();
			this.clearScreen = false;
		}
	}

	drawGame() {
		this.clear();
		this.ctx = this.canvas.getContext("2d");
		// this.ctx.font = "30px Arial";
		// this.ctx.fillStyle = "#0f0";
		// this.ctx.textAlign = "center";
		// this.ctx.fillText("Hello World!", this.canvas.width / 2, this.canvas.height / 2);
		forEachAgent(a => a.draw(this.ctx));
		//speechBubble(this.ctx, "this is\na test of text rendering\nwoah\nlol", agents[0].position, agents[1].position, agents[1].strokeColor);
		if (DRAWMATH) {
			WIRES.draw(this.ctx);
			spacePartition.draw(this.ctx, App.drawPartitionReferencingAgent);
		}
		if (this.collidingAgents) {
			for (let i = 0; i < this.collidingAgents.length; ++i) {
				let a = this.collidingAgents[i];
				this.ctx.beginPath();
				this.ctx.arc(a.position.x, a.position.y, a.radius+15, 0, 2 * Math.PI);
				this.ctx.stroke();
			}
		}
	}

	static drawPartitionReferencingAgent(ctx, partition, agent) {
		ctx.beginPath();
		let center = partition.aabb.getCenter();
		ctx.moveTo(center.x, center.y);
		ctx.lineTo(agent.position.x, agent.position.y);
		ctx.stroke();
	}

	update() {
		this.updateTiming();
		spacePartition.populate(agents, Agent.getCircle);
		let timeHasPassed = this.deltaTime > 0;
		if (timeHasPassed) { 
			let deltaTime = this.deltaTime / 1000;
			forEachAgent(a => a.update(deltaTime));
			forEachAgent(a => a.updateApplyPhysics(deltaTime));
			this.enforceCollisionDetection();
		}
		this.collidingAgents = spacePartition.getCollisions(new Circle(this.mouse, 20), Agent.getCircle);
		//console.log(this.collidingAgents);
		//this.collidingAgents = spacePartition.getPartitions(new Circle(this.mouse, 20));
	}

	enforceCollisionDetection() {
		let collisionsPerAgent = {};
		forEachAgent(a => {
			if (!a) { return; }
			let collisions = collisionHappening(a);
			if (collisions != null) {
				let collisionsHappeningToAgent = collisionsPerAgent[a.name];
				if (!collisionsHappeningToAgent) {
					collisionsHappeningToAgent = [];
				}
				for (let i = 0; i < collisions.length; i++) {
					collisionsHappeningToAgent.push(collisions[i]);
				}
				collisionsPerAgent[a.name] = collisionsHappeningToAgent;
			}
		});
		for (let agentname in collisionsPerAgent) {
			let collisions = collisionsPerAgent[agentname];
			let collisionAdjustment = new V2(0,0);
			for(let i = 0; i < collisions.length; i++) {
				let collision = collisions[i];
				collisionAdjustment.add(collision.resolution[0]);
			}
			collisionAdjustment.div(collisions.length);
			let agent = collisions[0].agent[0];
			agent.position.add(collisionAdjustment);
		}
	}

	updateTiming() {
		this.now = Date.now();
		let deltaTime = this.now - this.then;
		if (deltaTime) {
			if (deltaTime > 1000) {
				deltaTime = 1000;
			}
			this.deltaTime = deltaTime;
		}
		this.then = this.now;
	}

	clear() {
		this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
	}
};

class Wire {
	constructor() { }
	draw(ctx) {
		this.drawAlgorithm(ctx);
	}
	drawLine(ctx) {
		ctx.strokeStyle = this.color;
		ctx.lineWidth = this.thickness;
		ctx.beginPath();
		ctx.moveTo(this.start.x, this.start.y);
		ctx.lineTo(this.end.x, this.end.y);
		ctx.stroke();
	}
	drawCircle(ctx) {
		ctx.strokeStyle = this.color;
		ctx.lineWidth = this.thickness;
		ctx.beginPath();
		ctx.arc(this.position.x, this.position.y, this.radius, 0, 2 * Math.PI);
		ctx.stroke();
	}
	line(start, end, color = "black", thickness = 1) {
		this.start = start; this.end = end; this.color = color; this.thickness = thickness;
		this.drawAlgorithm = this.drawLine;
	}
	circle(center, radius, color = "black", thickness = 1) {
		this.position = center; this.radius = radius; this.color = color; this.thickness = thickness;
		this.drawAlgorithm = this.drawCircle;
	}
}

class Wires {
	constructor() {
		this.wires = {};
	}
	make(name) {
		let found = this.wires[name];
		if (found) { return found; }
		found = new Wire()
		found.name = name;
		this.wires[name] = found;
		return found;
	}
	draw(ctx) {
		for (const [key, value] of Object.entries(this.wires)) {
			if (key.hidden) { continue; }
			value.draw(ctx);
		}
	}
}
var WIRES = new Wires();
var DOT_TEST = 0;

class BasicBehavior {
	static update (agent, deltaTime) {
		if (agent.target) {
			WIRES.make(agent.name + "target").circle(agent.target, 2);
			let delta = V2.diff(agent.target, agent.position);
			let distance = delta.magnitude();
			if (distance < agent.radius) {
				agent.velocity = new V2(0,0);
			} else {
				let direction = V2.quotient(delta, distance);
				agent.velocity = V2.prod(direction, agent.speed);
			}
		}
	}
}

class SeekBehavior {
	constructor(onArrival) {
		this.onArrival = onArrival;
	}
	//execute(agent, deltaTime) {
	//	let finished = update(agent, deltaTime);
	//	if (this.onArrival && finished) {
	//		this.onArrival();
	//	}
	//}
	static update (agent, deltaTime) {
		if (!agent.target) { return false; }
		//console.log(agent.target, agent.position);
		WIRES.make(agent.name + "target").circle(agent.target, 2);
		if (DRAWMATH) {
			WIRES.make(agent.name + "currentVelocity").line(agent.position, V2.sum(agent.position, agent.velocity), 'black');
		}
		let targetDelta = V2.diff(agent.target, agent.position);
		let targetDistance = targetDelta.magnitude();
		let currentSpeed = agent.velocity.magnitude();
		let moveThisFrame = currentSpeed * deltaTime;
		let actualForceThisFrame = agent.acceleration * deltaTime;
		if (targetDistance < moveThisFrame) {//} && (currentSpeed - actualForceThisFrame) <= agent.targetEndingSpeed) {
			return true;
		}
		let targetDirection = V2.quotient(targetDelta, targetDistance);
		let velocityDirection = V2.quotient(agent.velocity, currentSpeed);

		let useStopLogic = agent.targetEndingSpeed !== undefined;
		let currentExpectedMovement = new V2(agent.velocity);
		let desiredVelocity = V2.prod(targetDirection, agent.speed);
		let whereAmIGoing = desiredVelocity;
		let desiredSteeringForce= V2.diff(desiredVelocity, currentExpectedMovement);

		if (useStopLogic) {
			let amountOfSpeedToStop = currentSpeed;
			if (agent.targetEndingSpeed) {
				amountOfSpeedToStop - agent.targetEndingSpeed;
			}
			let brakeDistance = amountOfSpeedToStop * amountOfSpeedToStop / (2 * agent.acceleration);
			let stoppingVector = V2.prod(velocityDirection, brakeDistance);
			if (DRAWMATH) {
				let brakePosition = V2.sum(agent.position, stoppingVector);
				WIRES.make(agent.name + "brakedistance").line(agent.position, brakePosition, 'red');
			}
			currentExpectedMovement.copy(stoppingVector);
			let stopping = false;
			let desiredFinalVelocity = new V2(0,0);
			if (agent.targetEndingSpeed) {
				desiredFinalVelocity = V2.prod(targetDirection, agent.targetEndingSpeed);
			}
			if (brakeDistance > targetDistance) {
				let alignmentWithBrakes = V2.dot(targetDirection, velocityDirection);
				if (alignmentWithBrakes > 0) {
					desiredVelocity = desiredFinalVelocity;
					stopping = true;
				}
			}
			let needsToBrake = brakeDistance > 0 && brakeDistance >= targetDistance;
			if (needsToBrake) {
				desiredSteeringForce.copy(V2.diff(desiredFinalVelocity, currentExpectedMovement));
				whereAmIGoing = desiredFinalVelocity;
			}
			if (DRAWMATH) {
				let brakeColor = needsToBrake ? 'red' : 'green';
				let brakePosition = V2.sum(agent.position, stoppingVector);
				WIRES.make(agent.name + "brakeposition").circle(brakePosition, agent.radius, brakeColor);
			}
			if (!stopping) {
				whereAmIGoing = V2.prod(targetDirection, brakeDistance);
				let hardSteeringForce = V2.diff(whereAmIGoing, currentExpectedMovement);
				const dotIsCloseEnough = 15/16;
				let steeringIsInTheRightDirection = V2.dot(hardSteeringForce, desiredVelocity) > 1;
				if (steeringIsInTheRightDirection) {
					desiredSteeringForce.copy(hardSteeringForce);
				} else {
					desiredSteeringForce.copy(desiredVelocity);
				}
				agent.lastSteeringForce = desiredSteeringForce;
			}
		}
		
		let steeringDirection = desiredSteeringForce.normalized();
		if (DRAWMATH) {
			let actualSteeringForce = V2.prod(steeringDirection, agent.acceleration);
			let velocityEndPoint = V2.sum(agent.position, desiredVelocity);
			let whereAmIGoingEndPoint = V2.sum(agent.position, whereAmIGoing);
			WIRES.make(agent.name + "desiredVelocity").line(agent.position, velocityEndPoint, 'blue');
			WIRES.make(agent.name + "currentVelocity").line(whereAmIGoingEndPoint, V2.diff(whereAmIGoingEndPoint, currentExpectedMovement), 'gray');
			WIRES.make(agent.name + "steeringforce").line(agent.position, V2.sum(agent.position, actualSteeringForce), 'magenta');
		}
		let accelerationThisFrame = V2.prod(steeringDirection, actualForceThisFrame);
		if (agent.velocity) {
			agent.velocity.add(accelerationThisFrame);
		} else {
			agent.velocity = accelerationThisFrame;
		}

		if (targetDistance < actualForceThisFrame && currentSpeed < actualForceThisFrame/4) {
			agent.velocity.set(0, 0);
			agent.position = agent.target;
		} else {
			agent.enforceSpeedLimit();
		}
		return false;
	}
}

class RandomWalkBehavior {
	constructor(radiusMin, radiusMax = undefined, timeout = 5) {
		this.radMin = radiusMin;
		this.radMax = radiusMax;
		this.timeout = timeout;
		this.timer = 0;
	}

	pickNextTarget(agent) {
		let angleRadian = Math.random() * Math.PI * 2;
		let direction = new V2(Math.cos(angleRadian), Math.sin(angleRadian));
		let radius = this.radMin;
		if (this.radMax !== undefined) {
			let radDelta = this.radMax - this.radMin;
			radius = this.radMin + Math.random() * radDelta;
		}
		let targetDelta = V2.prod(direction, radius);
		agent.target = V2.sum(agent.position, targetDelta);
		agent.targetEndingSpeed = 10;
	}

	update(agent, deltaTime) {
		this.timer += deltaTime;
		//agent.targetEndingSpeed = 1; // TODO why do they not move when this is uncommented?
		if (this.timer >= this.timeout || SeekBehavior.update(agent, deltaTime)) {
			this.pickNextTarget(agent);
			this.timer = 0;
		}
	}
}

class StayInAreaBehavior {
	constructor(min, max, normalUpdate, oobAction) {
		this.area = new AABB(min, max);
		this.updateBehavior = normalUpdate; this.oobAction = oobAction;
	}
	update(agent, deltaTime) {
		if (!agent.target || !this.area.contains(agent.target)) {
			this.oobAction();
		} else {
			this.updateBehavior(agent, deltaTime);
		}
	}
}

const STATE_NONE = 0;
const STATE_HOVERED = 1;
const STATE_SELECTED = 2;
class Agent {
	static getCircle(agent) { return new Circle(agent.position, agent.radius); }
	constructor(name, position, radius, speed, acceleration, internalClock = 3, mass = 1, fillColor = 'gray', strokeColor = 'black', borderThickness = 0.25) {
		this.name = name;
		this.position = position;
		this.velocity = new V2(0,0);
		this.radius = radius;
		this.speed = speed;
		this.mass = mass;
		this.acceleration = acceleration;
		this.strokeColor = strokeColor;
		this.fillColor = fillColor;
		this.borderThickness = borderThickness;
		this.selectionState = STATE_NONE;
		// \\this.updateBehavior = (agent,deltaTime) => SeekBehavior.update(agent,deltaTime);
		this.randomWalkBehavior = new RandomWalkBehavior(this.radius, this.radius*3, internalClock);
		this.stayInBounds = new StayInAreaBehavior(new V2(), new V2(WORLD_WIDTH,WORLD_HEIGHT),
		(agent, deltaTime) => this.randomWalkBehavior.update(agent, deltaTime),
		() => {
			if (!this.stayInBounds.area.contains(this.position)) {
				this.target = new V2(WORLD_WIDTH/2, WORLD_HEIGHT/2);
			} else {
				this.randomWalkBehavior.pickNextTarget(this);
			}
		});
		this.updateBehavior = this._updateBehaviorTree;
	}
	_updateBehaviorTree(agent, deltaTime) {
		this.stayInBounds.update(agent, deltaTime);
	}

	draw(ctx) {
		ctx.beginPath();
		if (this.strokeColor) {
			ctx.strokeStyle = this.strokeColor;
		}
		ctx.lineWidth = this.borderThickness;
		if (this.selectionState == STATE_HOVERED || this.selectionState == STATE_SELECTED) {
			ctx.lineWidth *= 10;
		}
		ctx.arc(this.position.x, this.position.y, this.radius, 0, 2 * Math.PI);
		if (this.fillColor) {
			ctx.fillStyle = this.fillColor;
			if (this.fillColor.startsWith('#')) {
				if (this.selectionState == STATE_HOVERED) {
					ctx.fillStyle = this.fillColor+"aa";
				}
				else if (this.selectionState == STATE_SELECTED) {
					ctx.fillStyle = this.fillColor+"88";
				}
			}
			ctx.fill();
		}
		//ctx.moveTo(this.position.x, this.position.y);
		//let endPoint = V2.sum(this.position, this.velocity);
		//ctx.lineTo(endPoint.x, endPoint.y);
		ctx.stroke();
		if (this.stopDistance) {
			let moveDir = this.velocity.normalized();
			let stopVector = V2.prod(moveDir, this.stopDistance);
			let stopPosition = V2.sum(this.position, stopVector);
			ctx.beginPath();
			ctx.fillStyle = undefined;
			ctx.arc(stopPosition.x, stopPosition.y, this.radius, 0, 2 * Math.PI);
			ctx.stroke();
		}
	}

	contains(point) {
		return V2.distance(this.position, point) <= this.radius;
	}

	update(deltaTime) {
		if (this.updateBehavior) {
			this.updateBehavior(this, deltaTime);
		} else {
			BasicBehavior.update(this, deltaTime);
		}
	}

	updateApplyPhysics(deltaTime) {
		if (this.velocity) {
			let movedThisFrame = V2.prod(this.velocity, deltaTime);
			this.position.add(movedThisFrame);
		}
	}

	setTarget(x, y) {
		this.target = new V2(x, y);
		this.targetEndingSpeed = 0;
		//console.log(this.fillColor, this.target, this.position);
	}

	setEndOfLine(x, y) {
		this.setTarget(x, y);
	}

	enforceSpeedLimit() {
		let currentSpeed = this.velocity.magnitude();
		if (currentSpeed > this.speed) {
			let velocityDirection = V2.quotient(this.velocity, currentSpeed);
			this.velocity = V2.prod(velocityDirection, this.speed);
		}
	}

	static collision(agent0, agent1) {
		let sumRadius = agent0.radius + agent1.radius;
		let delta = V2.diff(agent1.position, agent0.position);
		let distance = delta.magnitude();
		if (sumRadius > distance) {
			let overlap = sumRadius - distance;
			let direction = V2.quotient(delta, distance);
			let totalMass = agent0.mass + agent1.mass;
			let offset0 = -overlap*agent1.mass/totalMass;
			let offset1 = overlap*agent0.mass/totalMass;
			let resolution0 = V2.prod(direction, offset0);
			let resolution1 = V2.prod(direction, offset1);
			let collisionData = {
				agent: [ agent0, agent1 ],
				position: [ agent0.position, agent1.position ],
				resolution: [ resolution0, resolution1 ]
			};
			return collisionData;
		}
		return null;
	}
};

APP = new App();
agents = [
	// new Agent("Bluey", new V2(0,0), 20, 50, 100, 3, 5, 'cyan', 'blue', 0.25),
	// new Agent("Red", new V2(100,100), 10, 200, 20, 1, 10, 'orange', 'red', 0.25),
	// new Agent("gray", new V2(40,300), 8, 100, 50),
];

const SILLY_NAMES = ["bitty","bore","bug","bum", "dinq", "fuzz", "goo", "gum", "hick", "pea", "shoo", "slug", "sniff", "stink", "trash", "worm", "zoo", "fig", "chew", "beanie", "mad", "egg", "wee", "lick", "fart", "buzz", "fluff", "poop", "barf", "rat", "bobo", "booger", "fudge", "doozy", "hippy", "jiggy", "dink", "oink", "roach", "snot", "sock", "toot", "pie", "wiggle", "spotty", "hobo", "woof", "noodle", "droopy", "pants", "moo", "buns", "kins", "face", "ball", "rider", "worth", "ton"];
function getRandomInt(max) { return Math.floor(Math.random() * max); }
function randomNameBit() {
	return SILLY_NAMES[getRandomInt(SILLY_NAMES.length)];
}
function generateSillyName() {
	return randomNameBit()+" "+randomNameBit()+randomNameBit();
}
var agentDictionary = {};
function generateUniqueSillyName(){
	let sillyName = generateSillyName();
	let guard = 0;
	do {
		if (++guard > 100) { throw "too many silly names? "+Object.keys(agentDictionary).length;}
		sillyName = generateSillyName();
	} while (agentDictionary[sillyName] !== undefined);
	agentDictionary[sillyName] = 1;
	return sillyName;
}

for(let i = 0; i < 130; ++i) {
	let sillyName = generateUniqueSillyName();
	let position = new V2(Math.random()*WORLD_WIDTH, Math.random()*WORLD_HEIGHT);
	let radius = 5 + 15 * Math.random();
	let speed = 5 + 95 * Math.random();
	let acceleration = 5 + 95 * Math.random();
	let mass = 1 + 100 * Math.random();
	let fillColor = "#" + Math.floor(Math.random()*16777215).toString(16);
	let strokeColor = "#" + Math.floor(Math.random()*16777215).toString(16);
	let internalClock = 2 + 8 * Math.random();
	let agent = new Agent(sillyName, position, radius, speed, acceleration, internalClock, mass, fillColor, strokeColor);
	//console.log(sillyName);
	agents.push(agent);
}

function mouseMoveInterrupt(e) {
	APP.updateMousePosition(e || window.event);
}

function keyDownInterrupt(e) {
	APP.updateKeyInput(e || window.event);
	if (!e) { e = window.event; }
	if (e.keyCode === 187) { // =
		testP += 1/8;
	}
	if (e.keyCode === 189) { // -
		testP -= 1/8;
	}
	if (e.keyCode === 27) { 
		DRAWMATH = !DRAWMATH;
	}
}

function getTextRectSize(ctx, text) {
	let metrics = ctx.measureText(text);
	let fontHeight = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;
	let actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
	let actualWidth = ctx.measureText(text).width;
	return new V2(actualWidth, actualHeight);
}

function speechBubble(ctx, text, position, speechSource, bubbleLine = '#888', bubbleColor = '#fffa', textColor = '#222') {
	ctx.font = "12px Arial";
	ctx.textAlign = "center";
	let metrics = ctx.measureText(text);
	let line = text.split("\n");
	let totalRect = new V2(0,0);
	let lineRects = [];
	let lineSpacing = 5;
	for(let i = 0; i < line.length; i++) {
		if (i > 0) {
			totalRect.y += lineSpacing;
		}
		let lineSize = getTextRectSize(ctx, line[i]);
		lineRects.push(lineSize);
		if (totalRect.x < lineSize.x) {
			totalRect.x = lineSize.x;
		}
		totalRect.y += lineSize.y;
	}
	let p = new V2(position);
	let extraSize = V2.prod(totalRect, 0.125);
	totalRect.add(extraSize);
	ctx.strokeStyle = bubbleLine;
	ctx.fillStyle = bubbleColor;
	drawOvalWordBubble(ctx, p, totalRect, speechSource);
	p.y += extraSize.y/2;
	let cursor = V2.diff(p, new V2(0, totalRect.y/2));
	const descentOffset = metrics.fontBoundingBoxDescent/2;
	for (let i = 0; i < line.length; ++i) {
		let lineSize = lineRects[i];//getTextRectSize(ctx, line[i]);
		// ctx.strokeStyle = '#fff4';
		// ctx.fillStyle = "#fff";
		// ctx.beginPath();
		// ctx.rect(cursor.x - lineSize.x/2, cursor.y + descentOffset, lineSize.x, lineSize.y);
		// ctx.fill();
		// ctx.stroke();
		ctx.fillStyle = textColor;
		ctx.fillText(line[i], cursor.x, cursor.y + lineSize.y);
		cursor.y += lineSize.y + lineSpacing;
	}
}

var circle32 = [];
for (let i = 0; i < Math.PI * 2; i += Math.PI/16) {
	circle32.push(new V2(Math.cos(i)/2, Math.sin(i)/2));
}

function drawOvalWordBubble(ctx, center, size, source, precomputedVerts) {
	if (!precomputedVerts) {
		precomputedVerts = calculateOvalWordBubble(center, size, source);
	}
	ctx.beginPath();
	let vert = precomputedVerts[0];
	ctx.moveTo(vert.x, vert.y)
	for (let i = 1; i < precomputedVerts.length; i++) {
		vert = precomputedVerts[i];
		ctx.lineTo(vert.x, vert.y);
	}
	ctx.fill();
	ctx.stroke();
}

function calculateOvalWordBubble(center, size, source) {
	let points = [];
	let last = circle32.length-1;
	let x = circle32[last].x * size.x;
	let y = circle32[last].y * size.y;
	points.push(new V2(x,y));
	let lastPoint = new V2(x,y);
	let thisPoint = new V2(x,y);
	let toSource = V2.diff(source, center);
	let lastSign = V2.sign(toSource, thisPoint) > 0;
	for(let i = 0; i < 32; ++i) {
		x = circle32[i].x * size.x;
		y = circle32[i].y * size.y;
		thisPoint.set(x,y);
		let thisSign = V2.sign(toSource, thisPoint) > 0;
		if (lastSign != thisSign && V2.dot(thisPoint, toSource) > 0) {
			points.push(source);
		}
		lastSign = thisSign;
		points.push(new V2(x + center.x, y + center.y));
		lastPoint.set(x, y);
	}
	return points;
}

function mouseDownInterrupt(e) {
	APP.updateMouseDownInput(e || window.event);
}
		</script>
		<br>
		could we implement <a href="https://www.red3d.com/cwr/steer/gdc99/">steering</a>
		<a href="https://devforum.roblox.com/t/introduction-to-steering-behaviors/1441680/6">behavior</a>
		for our agent?
	</body>
</html>
