<!DOCTYPE html>
<html>
	<head>
	<style>
		body { margin:0; padding:0; }
	</style>
	</head>
	<body onload="mainLoop()" onmousemove="mouseMoveInterrupt()" onkeydown="keyDownInterrupt()" onmousedown="mouseDownInterrupt()">
		<script src="v2.js" type="text/javascript"></script>
		<script src="circle.js" type="text/javascript"></script>
		<script>
const WORLD_WIDTH = 800;
const WORLD_HEIGHT = 600;
const TARGET_FPS = 30;
var APP;
var agents;

var collisionHappening = function (agent) {
	let listOfCollisions = null;
	let agentCircle = Agent.getCircle(agent);
	let collidingAgents = getCollisions(agentCircle);
	if (!collidingAgents || collidingAgents.length == 0) {
		return null;
	}
	let collisionHappening = false;
	for (let i = 0; i < collidingAgents.length; i++) {
		let a = collidingAgents[i];
		let agentCollidingWithSelf = a == agent;
		if (agentCollidingWithSelf) { continue; }
		let collisionData = Agent.computePenetration(agent, a);
		if (collisionData != null) {
			if (listOfCollisions == null) {
				listOfCollisions = [collisionData];
			} else {
				listOfCollisions.push(collisionData);
			}
		}
	}
	return listOfCollisions;
}

function getCollisions(circle) {
	let collisions = [];
	for(let i = 0; i < agents.length; i++) {
		let agent = agents[i];
		let distance = V2.distance(circle.center, agent.position);
		let minDistance = circle.radius + agent.radius;
		if (distance < minDistance) {
			collisions.push(agent);
		}
	}
	return collisions;
}

function forEachAgent(whatToDo) {
	for (let i = 0; i < agents.length; i++) {
		whatToDo(agents[i]);
	}
}

function mainLoop() {
	APP.processInput();
	APP.update();
	APP.drawGame();
	setTimeout(mainLoop, APP.frameDelay);
}

class App {
	constructor() {
		this.canvas = document.createElement("canvas");
		this.now = Date.now();
		this.then = Date.now();
		this.targetFps = TARGET_FPS;
		this.frameDelay = 1000 / this.targetFps;
		this.mouse = new V2(0,0);
		this.canvas.width = WORLD_WIDTH;
		this.canvas.height = WORLD_HEIGHT;
		this.context = this.canvas.getContext("2d");
		document.body.insertBefore(this.canvas, document.body.childNodes[0]);
		document.onkeydown = this.userkey;
	}

	updateKeyInput(e) {
		const ESCAPE = 27;
		if (e.keyCode === ESCAPE) {
			console.log("escape was pressed!");
		} else {
			console.log("key: " + e.keyCode)
		}
	};

	updateMousePosition(e) {
		if (!e) {
			return;
		}
		this.mouse.set(e.clientX, e.clientY);
	}

	updateMouseDownInput(e) {
		this.updateMousePosition(e);
	}

	processInput() {
		if (this.mouse) {
			let player = agents[0];
			let playerDelta = V2.diff(this.mouse, player.position);
			let desiredVelocity = playerDelta;
			let magnitude = playerDelta.magnitude();
			const maxSpeed = 100;
			if (magnitude > maxSpeed) {
				let direction = V2.quotient(playerDelta, magnitude);
				desiredVelocity = V2.prod(direction, 100);
			}
			player.velocity = desiredVelocity;
		}
	}

	drawGame() {
		this.clear();
		this.ctx = this.canvas.getContext("2d");
		forEachAgent(a => a.draw(this.ctx));
	}

	update() {
		this.updateTiming();
		let timeHasPassed = this.deltaTime > 0;
		if (timeHasPassed) { 
			let deltaTime = this.deltaTime / 1000;
			forEachAgent(a => a.update(deltaTime));
			forEachAgent(a => a.updateApplyPhysics(deltaTime));
			this.enforceCollisionDetection();
		}
	}

	enforceCollisionDetection() {
		let collisionsPerAgent = {};
		forEachAgent(a => {
			if (!a) { return; }
			let collisions = collisionHappening(a);
			if (collisions != null) {
				let collisionsHappeningToAgent = collisionsPerAgent[a.name];
				if (!collisionsHappeningToAgent) {
					collisionsHappeningToAgent = [];
				}
				for (let i = 0; i < collisions.length; i++) {
					collisionsHappeningToAgent.push(collisions[i]);
				}
				collisionsPerAgent[a.name] = collisionsHappeningToAgent;
			}
		});
		for (let agentname in collisionsPerAgent) {
			let collisions = collisionsPerAgent[agentname];
			let collisionAdjustment = new V2(0,0);
			for(let i = 0; i < collisions.length; i++) {
				let collision = collisions[i];
				collisionAdjustment.add(collision.resolution[0]);
			}
			let agent = collisions[0].agent[0];
			agent.position.add(collisionAdjustment);
		}
	}

	updateTiming() {
		this.now = Date.now();
		let deltaTime = this.now - this.then;
		if (deltaTime) {
			if (deltaTime > 1000) {
				deltaTime = 1000;
			}
			this.deltaTime = deltaTime;
		}
		this.then = this.now;
	}

	clear() {
		this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
	}
};

class Agent {
	static getCircle(agent) { return new Circle(agent.position, agent.radius); }
	constructor(name, position, radius, speed, acceleration, internalClock = 3, mass = 1, fillColor = 'gray', strokeColor = 'black', borderThickness = 0.25) {
		this.name = name;
		this.position = position;
		this.velocity = new V2(0,0);
		this.radius = radius;
		this.speed = speed;
		this.mass = mass;
		this.acceleration = acceleration;
		this.strokeColor = strokeColor;
		this.fillColor = fillColor;
		this.borderThickness = borderThickness;
	}

	draw(ctx) {
		ctx.beginPath();
		if (this.strokeColor) {
			ctx.strokeStyle = this.strokeColor;
		}
		ctx.lineWidth = this.borderThickness;
		ctx.arc(this.position.x, this.position.y, this.radius, 0, 2 * Math.PI);
		if (this.fillColor) {
			ctx.fillStyle = this.fillColor;
			ctx.fill();
		}
		ctx.stroke();
	}

	contains(point) {
		return V2.distance(this.position, point) <= this.radius;
	}

	update(deltaTime) {
		this.updateApplyPhysics(deltaTime);
	}

	updateApplyPhysics(deltaTime) {
		if (this.velocity) {
			let movedThisFrame = V2.prod(this.velocity, deltaTime);
			this.position.add(movedThisFrame);
		}
	}

	static computePenetration(agent0, agent1) {
		let sumRadius = agent0.radius + agent1.radius;
		let delta = V2.diff(agent1.position, agent0.position);
		let distance = delta.magnitude();
		if (sumRadius > distance) {
			let overlap = sumRadius - distance;
			let direction = V2.quotient(delta, distance);
			let totalMass = agent0.mass + agent1.mass;
			let offset0 = -overlap*agent1.mass/totalMass;
			let offset1 = overlap*agent0.mass/totalMass;
			let resolution0 = V2.prod(direction, offset0);
			let resolution1 = V2.prod(direction, offset1);
			let collisionData = {
				agent: [ agent0, agent1 ],
				position: [ agent0.position, agent1.position ],
				resolution: [ resolution0, resolution1 ]
			};
			return collisionData;
		}
		return null;
	}
};

APP = new App();
agents = [];

(function generateAgents() {
	function randomColor() { return Math.floor(Math.random()*16777215).toString(16); }
for(let i = 0; i < 130; ++i) {
	let name = "agent"+i;
	let position = new V2(Math.random()*WORLD_WIDTH, Math.random()*WORLD_HEIGHT);
	let radius = 5 + 15 * Math.random();
	let speed = 5 + 95 * Math.random();
	let acceleration = 5 + 95 * Math.random();
	let mass = 1 + 100 * Math.random();
	let fillColor = "#" + randomColor();
	let strokeColor = "#" + randomColor();
	let internalClock = 2 + 8 * Math.random();
	let agent = new Agent(name, position, radius, speed, acceleration, internalClock, mass, fillColor, strokeColor);
	agents.push(agent);
}
})();

function mouseMoveInterrupt(e) {
	APP.updateMousePosition(e || window.event);
}

function keyDownInterrupt(e) {
	APP.updateKeyInput(e || window.event);
}


function mouseDownInterrupt(e) {
	APP.updateMouseDownInput(e || window.event);
}
		</script>
	</body>
</html>
